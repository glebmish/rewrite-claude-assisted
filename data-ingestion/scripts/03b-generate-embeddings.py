#!/usr/bin/env python3
"""
Script: 03b-generate-embeddings.py
Purpose: Generate semantic embeddings for recipes from structured metadata

This script:
1. Reads recipe metadata from JSON (generated by 02b-generate-structured-data.sh)
2. Creates structured embedding text for each recipe
3. Generates embeddings using sentence-transformers
4. Stores embeddings and metadata in PostgreSQL

Note: This script expects:
- PostgreSQL database running with schema initialized
- Recipes already ingested by 03-ingest-docs.py
- Recipe metadata JSON file generated by 02b-generate-structured-data.sh
"""

import asyncio
import asyncpg
import json
import sys
from typing import List, Dict, Optional
from tqdm import tqdm

# Import sentence transformers (will be installed via requirements.txt)
try:
    from sentence_transformers import SentenceTransformer
except ImportError:
    print("Error: sentence-transformers not installed.", file=sys.stderr)
    print("Install with: pip install sentence-transformers", file=sys.stderr)
    sys.exit(1)

# Import common utilities
from common import ScriptConfig, Logger, get_db_connection

# Initialize configuration
config = ScriptConfig()
logger = Logger(verbose=config.VERBOSE)

# Get metadata file path
METADATA_FILE = config.get_metadata_file()


def create_embedding_text(metadata: Dict) -> str:
    """
    Create structured text for embedding from recipe metadata.

    Format:
        Recipe: [displayName or name]
        Description: [description]
        Tags: [comma-separated tags]
        Full name: [fully qualified name]

    Args:
        metadata: Recipe metadata dictionary

    Returns:
        Structured text suitable for embedding
    """
    name = metadata.get('name', '')
    display_name = metadata.get('displayName') or name.split('.')[-1]
    description = metadata.get('description', '')
    tags = metadata.get('tags', [])

    # Build structured text
    parts = [
        f"Recipe: {display_name}",
    ]

    if description:
        parts.append(f"Description: {description}")

    if tags:
        parts.append(f"Tags: {', '.join(tags)}")

    parts.append(f"Full name: {name}")

    return '\n'.join(parts)


async def get_recipe_id(conn: asyncpg.Connection, recipe_name: str) -> Optional[int]:
    """
    Get recipe_id for a given recipe name.

    Args:
        conn: Database connection
        recipe_name: Fully qualified recipe name

    Returns:
        Recipe ID if found, None otherwise
    """
    row = await conn.fetchrow(
        "SELECT id FROM recipes WHERE recipe_name = $1",
        recipe_name
    )
    return row['id'] if row else None


async def upsert_recipe_metadata(
    conn: asyncpg.Connection,
    recipe_id: int,
    metadata: Dict
):
    """
    Insert or update recipe metadata in the database.

    Args:
        conn: Database connection
        recipe_id: Recipe ID
        metadata: Recipe metadata dictionary
    """
    await conn.execute("""
        INSERT INTO recipe_metadata (
            recipe_id, display_name, description, tags,
            is_composite, recipe_count, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, NOW())
        ON CONFLICT (recipe_id) DO UPDATE SET
            display_name = EXCLUDED.display_name,
            description = EXCLUDED.description,
            tags = EXCLUDED.tags,
            is_composite = EXCLUDED.is_composite,
            recipe_count = EXCLUDED.recipe_count,
            updated_at = NOW()
    """,
        recipe_id,
        metadata.get('displayName'),
        metadata.get('description'),
        metadata.get('tags', []),
        metadata.get('isComposite', False),
        metadata.get('recipeCount', 0)
    )


async def upsert_recipe_embedding(
    conn: asyncpg.Connection,
    recipe_id: int,
    embedding: List[float],
    model_name: str
):
    """
    Insert or update recipe embedding in the database.

    Args:
        conn: Database connection
        recipe_id: Recipe ID
        embedding: Embedding vector
        model_name: Name of the embedding model
    """
    # Convert embedding to PostgreSQL vector format
    embedding_str = '[' + ','.join(str(x) for x in embedding) + ']'

    await conn.execute("""
        INSERT INTO recipe_embeddings (
            recipe_id, embedding, embedding_model
        ) VALUES ($1, $2::vector, $3)
        ON CONFLICT (recipe_id, embedding_model) DO UPDATE SET
            embedding = EXCLUDED.embedding,
            created_at = NOW()
    """,
        recipe_id,
        embedding_str,
        model_name
    )


async def process_recipes(metadata_list: List[Dict], model: SentenceTransformer):
    """
    Process all recipes: generate embeddings and store in database.

    Args:
        metadata_list: List of recipe metadata dictionaries
        model: Loaded sentence transformer model
    """
    # Connect to database
    logger.log(f"→ Connecting to database at {config.DB_HOST}:{config.DB_PORT}/{config.DB_NAME}...", force=True)
    conn = await get_db_connection(config)

    try:
        logger.log(f"✓ Connected to database", force=True)

        # Verify pgvector extension is installed
        logger.log(f"→ Verifying pgvector extension...", force=True)
        try:
            vector_version = await conn.fetchval("SELECT extversion FROM pg_extension WHERE extname = 'vector'")
            if vector_version:
                logger.log(f"✓ pgvector extension installed (version: {vector_version})", force=True)
            else:
                logger.log(f"✗ ERROR: pgvector extension not found!", force=True)
                logger.log(f"  Run 00-init-database.sh to initialize the database with pgvector", force=True)
                return
        except Exception as e:
            logger.log(f"✗ ERROR checking pgvector extension: {e}", force=True)
            return

        logger.log("", force=True)

        # Statistics
        processed = 0
        skipped = 0
        errors = 0

        # Process each recipe
        logger.log(f"→ Processing {len(metadata_list)} recipes...", force=True)
        with tqdm(total=len(metadata_list), desc="Generating embeddings", unit="recipe") as pbar:
            for metadata in metadata_list:
                recipe_name = metadata.get('name')
                if not recipe_name:
                    logger.log(f"  Warning: Skipping recipe with no name: {metadata}", force=config.VERBOSE)
                    skipped += 1
                    pbar.update(1)
                    continue

                try:
                    # Get recipe_id
                    recipe_id = await get_recipe_id(conn, recipe_name)
                    if recipe_id is None:
                        logger.log(f"  Warning: Recipe not found in database: {recipe_name}", force=config.VERBOSE)
                        skipped += 1
                        pbar.update(1)
                        continue

                    # Store metadata
                    try:
                        await upsert_recipe_metadata(conn, recipe_id, metadata)
                    except Exception as e:
                        logger.log(f"  ✗ Error storing metadata for {recipe_name}: {e}", force=True)
                        raise

                    # Create embedding text
                    embedding_text = create_embedding_text(metadata)

                    # Generate embedding
                    embedding = model.encode(embedding_text, show_progress_bar=False)

                    # Verify embedding dimension matches expected dimension
                    if len(embedding) != config.EMBEDDING_DIMENSION:
                        raise ValueError(f"Embedding dimension mismatch: expected {config.EMBEDDING_DIMENSION}, got {len(embedding)}")

                    # Store embedding with better error handling
                    try:
                        await upsert_recipe_embedding(
                            conn,
                            recipe_id,
                            embedding.tolist(),
                            config.EMBEDDING_MODEL
                        )
                        logger.log(f"  ✓ Stored embedding for: {recipe_name}", force=config.VERBOSE)
                    except Exception as e:
                        logger.log(f"  ✗ Error storing embedding for {recipe_name}: {type(e).__name__}: {e}", force=True)
                        raise

                    processed += 1
                    logger.log(f"  ✓ Processed: {recipe_name}", force=config.VERBOSE)

                except Exception as e:
                    logger.log(f"  ✗ Error processing {recipe_name}: {type(e).__name__}: {e}", force=True)
                    import traceback
                    logger.log(f"  Traceback: {traceback.format_exc()}", force=config.VERBOSE)
                    errors += 1

                pbar.update(1)

        logger.log("", force=True)
        logger.log("========================================", force=True)
        logger.log("Summary", force=True)
        logger.log("========================================", force=True)
        logger.log(f"Successfully processed: {processed}", force=True)
        logger.log(f"Skipped (not in DB): {skipped}", force=True)
        logger.log(f"Errors: {errors}", force=True)
        logger.log(f"Total: {len(metadata_list)}", force=True)

        # Verify embeddings were inserted
        logger.log("", force=True)
        logger.log("→ Verifying embeddings in database...", force=True)
        try:
            embedding_count = await conn.fetchval(
                "SELECT COUNT(*) FROM recipe_embeddings WHERE embedding_model = $1",
                config.EMBEDDING_MODEL
            )
            logger.log(f"✓ Embeddings in database for model '{config.EMBEDDING_MODEL}': {embedding_count}", force=True)

            if embedding_count == 0 and processed > 0:
                logger.log(f"⚠ WARNING: Processed {processed} recipes but no embeddings found in database!", force=True)
                logger.log(f"  This suggests embeddings are not being inserted properly.", force=True)
        except Exception as e:
            logger.log(f"✗ Error verifying embeddings: {e}", force=True)

    finally:
        await conn.close()


async def main():
    """Main function."""
    logger.print_stage_header("Stage 3b: Generate Recipe Embeddings")

    # Check if metadata file exists
    if not METADATA_FILE.exists():
        print(f"✗ Error: Metadata file not found: {METADATA_FILE}", file=sys.stderr)
        print(f"  Run 02b-generate-structured-data.sh first", file=sys.stderr)
        sys.exit(1)

    logger.log(f"✓ Found metadata file: {METADATA_FILE}", force=True)

    # Load metadata
    logger.log(f"→ Loading recipe metadata...", force=True)
    with open(METADATA_FILE, 'r') as f:
        metadata_list = json.load(f)

    logger.log(f"✓ Loaded {len(metadata_list)} recipes", force=True)
    logger.log("", force=True)

    # Load embedding model
    logger.log(f"→ Loading embedding model: {config.EMBEDDING_MODEL}...", force=True)
    logger.log(f"  (First run will download model, subsequent runs use cache)", force=True)
    model = SentenceTransformer(config.EMBEDDING_MODEL)
    logger.log(f"✓ Model loaded (dimension: {config.EMBEDDING_DIMENSION})", force=True)
    logger.log("", force=True)

    # Process recipes
    await process_recipes(metadata_list, model)

    logger.print_stage_footer("3b", "Run 04-create-image.sh")


if __name__ == '__main__':
    asyncio.run(main())
